# 手写 Mini-MySQL 实现规划

## 📊 项目概览

**目标**: 用 Java 实现简化版 MySQL，覆盖 85%+ 数据库八股文知识点
**时间**: 3-4 个月（每周 10-15 小时）
**难度**: ⭐⭐⭐⭐（高，但收益极大）

---

## 🏗️ 分层架构设计

采用自底向上的实现方式，符合学习曲线和依赖关系：

### Layer 1: 存储层（Storage Layer）
**核心组件**: Page 管理、B+ 树索引、文件 I/O
**对应八股文**: B+ 树原理、页结构、聚簇索引 vs 二级索引、回表查询

### Layer 2: 缓冲池层（Buffer Pool）
**核心组件**: LRU 缓存、脏页管理、预读机制
**对应八股文**: 缓冲池优化、缓存策略、刷盘机制

### Layer 3: 事务层（Transaction Layer）⭐⭐⭐ 核心重点
**核心组件**: MVCC、Undo Log、Redo Log、锁管理器
**对应八股文**: ACID、隔离级别、MVCC 原理、锁机制、日志系统

### Layer 4: 执行层（Execution Layer）
**核心组件**: SQL 解析器、查询优化器、执行引擎
**对应八股文**: SQL 执行流程、EXPLAIN、索引优化、JOIN 算法

### Layer 5: 网络层（Network Layer）
**核心组件**: MySQL 协议、连接管理
**对应八股文**: 连接过程、Binlog、两阶段提交

---

## 📅 分阶段实施路线图

### 阶段 1: 基础存储引擎（2-3 周）

**实现内容**:
- [ ] Page 页面管理（16KB 固定大小）
  - 页头（Page Header）
  - 页尾（Page Trailer）
  - 用户数据区
  - 页类型（数据页、索引页）

- [ ] B+ 树索引
  - 非叶子节点：键值 + 指针
  - 叶子节点：完整数据行
  - 叶子节点双向链表
  - 插入、查询、删除操作

- [ ] 文件 I/O 管理
  - 表空间文件
  - 页的持久化
  - RandomAccessFile 操作

**对应八股文知识点**:
- ✅ 为什么用 B+ 树而不是 B 树/红黑树？
- ✅ 为什么页大小是 16KB？
- ✅ 聚簇索引原理
- ✅ 索引组织表
- ✅ 为什么 3 层 B+ 树能存 2000 万数据？

**验收标准**: 能够存储和查询单表数据，支持主键索引

---

### 阶段 2: 缓冲池管理（1-2 周）

**实现内容**:
- [ ] LRU 链表（分代 LRU）
  - Young 区域（热数据）
  - Old 区域（预读数据）
  - Midpoint insertion

- [ ] Free List（空闲页链表）
- [ ] Flush List（脏页链表）
  - 按 LSN 排序
  - 刷盘策略

- [ ] 缓冲池统计信息

**对应八股文知识点**:
- ✅ 缓冲池的作用
- ✅ LRU 变种算法
- ✅ 脏页刷新机制
- ✅ 预读机制（线性预读、随机预读）
- ✅ 如何避免全表扫描污染缓存

**验收标准**: 缓冲池命中率统计，显著减少磁盘 I/O

---

### 阶段 3: 事务基础（2-3 周）

**实现内容**:
- [ ] 事务管理器
  - 全局递增事务 ID
  - 活跃事务列表
  - 事务状态管理

- [ ] Undo Log
  - 记录数据旧版本
  - Undo 页结构
  - 回滚操作

- [ ] Redo Log
  - WAL（Write-Ahead Logging）
  - Redo Log Buffer
  - 循环写入
  - Checkpoint 机制

- [ ] 崩溃恢复

**对应八股文知识点**:
- ✅ ACID 如何实现
- ✅ Undo Log 的双重作用（回滚 + MVCC）
- ✅ Redo Log 实现持久性
- ✅ WAL 机制
- ✅ Checkpoint 原理
- ✅ 崩溃恢复流程

**验收标准**: 支持 BEGIN、COMMIT、ROLLBACK，崩溃后能恢复

---

### 阶段 4: MVCC 和隔离级别（2-3 周）⭐⭐⭐ 核心重点

**实现内容**:
- [ ] 行记录隐藏字段
  - DB_TRX_ID（最后修改事务 ID）
  - DB_ROLL_PTR（回滚指针）
  - DB_ROW_ID（隐藏主键）

- [ ] ReadView 结构
  - m_ids（活跃事务列表）
  - min_trx_id（最小活跃事务 ID）
  - max_trx_id（下一个事务 ID）
  - creator_trx_id（创建者事务 ID）

- [ ] 可见性判断算法
  ```
  if trx_id == creator_trx_id: 可见
  if trx_id < min_trx_id: 可见
  if trx_id >= max_trx_id: 不可见
  if trx_id in m_ids: 不可见
  else: 可见
  ```

- [ ] 快照读实现
- [ ] Read Committed 隔离级别（每次读创建 ReadView）
- [ ] Repeatable Read 隔离级别（事务开始时创建 ReadView）

**对应八股文知识点**（最核心！）:
- ✅ MVCC 工作原理
- ✅ ReadView 可见性算法
- ✅ 四种隔离级别的实现
- ✅ 快照读 vs 当前读
- ✅ 为什么 RR 能防止不可重复读
- ✅ 幻读问题（需结合锁机制）

**验收标准**:
- 支持并发事务互不干扰
- Read Committed 能读到其他事务已提交的修改
- Repeatable Read 读到的数据保持一致

---

### 阶段 5: 锁机制（2 周）⭐⭐⭐ 核心重点

**实现内容**:
- [ ] 表级锁
  - 意向锁（IS、IX）
  - 表锁（S、X）

- [ ] 行级锁
  - 记录锁（Record Lock）
  - 间隙锁（Gap Lock）
  - Next-Key Lock（Record + Gap）
  - 插入意向锁

- [ ] 锁兼容矩阵
- [ ] 死锁检测
  - 等待图（Wait-For Graph）
  - 环路检测
  - 选择回滚事务

- [ ] 锁等待和超时

**对应八股文知识点**:
- ✅ 表锁 vs 行锁
- ✅ 共享锁 vs 排他锁
- ✅ 意向锁的作用
- ✅ 间隙锁如何解决幻读
- ✅ Next-Key Lock 原理
- ✅ 死锁的产生和检测
- ✅ 如何避免死锁
- ✅ 当前读加锁分析

**验收标准**:
- 防止脏写
- Repeatable Read + 间隙锁防止幻读
- 死锁检测正常工作

---

### 阶段 6: SQL 解析器（1-2 周）

**实现内容**:
- [ ] 词法分析器（Lexer）
  - 识别关键字、标识符、运算符

- [ ] 语法分析器（Parser）
  - 递归下降解析或 ANTLR
  - 生成 AST

- [ ] 支持的 SQL
  - SELECT、INSERT、UPDATE、DELETE
  - CREATE TABLE
  - WHERE、ORDER BY、LIMIT

**技术选型**: ANTLR 4（推荐）或手写递归下降

**验收标准**: 解析常见 SQL 语句，生成正确的 AST

---

### 阶段 7: 查询优化器（2 周）⭐⭐

**实现内容**:
- [ ] 二级索引实现
  - 叶子节点存储主键
  - 回表查询

- [ ] 统计信息收集
  - 表行数
  - 索引基数
  - 选择性

- [ ] 成本模型
  - I/O 成本
  - CPU 成本
  - 全表扫描 vs 索引扫描

- [ ] 索引选择算法
- [ ] 逻辑优化
  - 条件下推
  - 常量折叠

- [ ] EXPLAIN 实现

**对应八股文知识点**:
- ✅ SQL 执行流程
- ✅ EXPLAIN 分析
- ✅ 索引失效的场景
- ✅ 覆盖索引优化
- ✅ 索引选择策略
- ✅ 回表的代价
- ✅ 最左前缀原则

**验收标准**:
- 能够选择合适的索引
- 输出执行计划（类似 EXPLAIN）

---

### 阶段 8: 执行引擎（1-2 周）

**实现内容**:
- [ ] 火山模型（Volcano Model）
  - 迭代器模式

- [ ] 基础算子
  - TableScan（全表扫描）
  - IndexScan（索引扫描）
  - Filter（过滤）
  - Project（投影）
  - Sort（排序）
  - Limit

- [ ] JOIN 算子
  - Nested Loop Join（简化版）

**验收标准**: 执行 SQL 查询返回正确结果

---

### 阶段 9: 网络协议（1 周）

**实现内容**:
- [ ] MySQL 协议（简化版）
  - 握手协议
  - 认证（简化）
  - COM_QUERY
  - Result Set 返回

- [ ] 连接管理
  - 使用 Netty 或 Java NIO

- [ ] 会话管理

**验收标准**: 使用 MySQL 命令行客户端连接并执行查询

---

### 阶段 10: Binlog 和两阶段提交（1 周）⭐⭐

**实现内容**:
- [ ] Binlog 写入
  - Statement 格式（简化）

- [ ] 两阶段提交
  - Prepare 阶段（写 Redo Log）
  - Commit 阶段（写 Binlog + Redo Log）

- [ ] 崩溃恢复优化

**对应八股文知识点**:
- ✅ Redo Log vs Binlog 区别
- ✅ 两阶段提交流程
- ✅ 为什么需要两阶段提交
- ✅ Binlog 的三种格式
- ✅ 主从复制原理（简化版）

**验收标准**: 模拟崩溃恢复场景，数据不丢失

---

## 🛠️ 技术选型

### Java 技术栈
```yaml
基础:
  - JDK 11+
  - Lombok (减少样板代码)
  - Guava (集合工具)

并发:
  - ConcurrentHashMap
  - ReentrantReadWriteLock
  - AtomicLong (事务ID)

I/O:
  - RandomAccessFile
  - MappedByteBuffer (性能优化)
  - Netty (网络层)

SQL解析:
  - ANTLR 4 (推荐)
  - 或手写递归下降

测试:
  - JUnit 5
  - Mockito
  - JMH (性能测试)
```

### 项目结构
```
mini-mysql/
├── storage/          # 存储层
│   ├── page/        # 页面管理
│   ├── index/       # B+树索引
│   └── file/        # 文件I/O
├── buffer/          # 缓冲池
├── transaction/     # 事务管理
│   ├── mvcc/       # MVCC
│   ├── lock/       # 锁管理
│   └── log/        # Undo/Redo Log
├── sql/            # SQL层
│   ├── parser/     # 解析器
│   ├── optimizer/  # 优化器
│   └── executor/   # 执行器
├── network/        # 网络层
└── common/         # 通用工具
```

---

## 📚 学习资源

### 必读书籍
1. **《MySQL 技术内幕：InnoDB 存储引擎》**（姜承尧）⭐⭐⭐⭐⭐
   - 第 4 章：表（B+ 树、页结构）
   - 第 6 章：锁
   - 第 7 章：事务（MVCC、隔离级别）

2. **《高性能 MySQL》**
   - 索引优化章节

3. **官方文档**
   - MySQL InnoDB 架构文档
   - 事务隔离级别说明

### 参考项目
- **TinySQL**（PingCAP，Go 语言，教学项目）
- **SimpleDB**（伯克利大学，Java）

### 验证方法
```
每完成一个模块:
1. 手画流程图和数据结构
2. 自己出面试题，用代码回答
3. 对比真实 MySQL 行为
4. 写博客总结
```

---

## ⚠️ 关键注意事项

### 设计原则
- ✅ **简化但不简陋**: 保留核心概念，可简化边界情况
- ✅ **渐进式实现**: 先单线程 → 加并发 → 优化性能
- ✅ **充分测试**: 每个模块都要有单元测试

### 常见陷阱

**B+ 树**:
- ❌ 陷阱: 分裂/合并逻辑复杂
- ✅ 建议: 先实现只增不删版本

**MVCC**:
- ❌ 陷阱: 可见性判断容易出错
- ✅ 建议: 画流程图，穷举所有情况

**间隙锁**:
- ❌ 陷阱: 范围计算容易出错
- ✅ 建议: 先实现记录锁，再加间隙锁

**并发**:
- ❌ 陷阱: 死锁、竞态条件
- ✅ 建议: 使用 Java 并发工具类

---

## 🎯 八股文覆盖度评估

| 知识领域 | 覆盖度 | 重要性 |
|---------|--------|--------|
| 存储引擎（B+ 树、索引） | 90% | ⭐⭐⭐ |
| 事务（MVCC、隔离级别） | 100% | ⭐⭐⭐⭐⭐ |
| 锁机制 | 100% | ⭐⭐⭐⭐⭐ |
| 日志系统（Undo/Redo/Binlog） | 95% | ⭐⭐⭐⭐ |
| 查询优化 | 80% | ⭐⭐⭐ |
| 缓冲池 | 85% | ⭐⭐⭐ |
| 网络协议 | 60% | ⭐⭐ |
| **总体覆盖** | **85%+** | |

---

## 🚀 立即开始（第一步）

### 本周任务清单
- [ ] 创建 Maven/Gradle 项目
- [ ] 设计包结构
- [ ] 添加依赖（Lombok、Guava、JUnit）
- [ ] 购买/借阅《MySQL 技术内幕》
- [ ] 阅读第 4 章（表结构和 B+ 树）

### 第一个里程碑：实现 Page 类
```java
// 目标结构（伪代码）
class Page {
    static final int PAGE_SIZE = 16 * 1024; // 16KB

    PageHeader header;
    byte[] data;
    PageTrailer trailer;

    void write(byte[] data);
    byte[] read();
    void serialize(File file);
    static Page deserialize(File file);
}
```

**验收标准**（1 周内完成）:
- [ ] 能够创建 Page 对象
- [ ] 能够写入数据到 Page
- [ ] 能够持久化到文件
- [ ] 能够从文件读取 Page
- [ ] 单元测试覆盖率 > 80%

---

## 💡 学习心态建议

**这是一个长期项目（3-4 个月），关键是：**
- 不要急于求成，每个模块都要扎实掌握
- 卡住了就看书、画图、参考源码
- 每完成一个模块，就掌握了一块八股文
- 保持好奇心和成就感

**这个方法论的价值：**
- ✅ 深度理解 > 死记硬背
- ✅ 能讲出原理 > 背出答案
- ✅ 面试时底气十足
- ✅ 对职业发展有长期价值

---

## 📈 进度追踪

### 完成情况
- [ ] 阶段 1: 基础存储引擎
- [ ] 阶段 2: 缓冲池管理
- [ ] 阶段 3: 事务基础
- [ ] 阶段 4: MVCC 和隔离级别
- [ ] 阶段 5: 锁机制
- [ ] 阶段 6: SQL 解析器
- [ ] 阶段 7: 查询优化器
- [ ] 阶段 8: 执行引擎
- [ ] 阶段 9: 网络协议
- [ ] 阶段 10: Binlog 和两阶段提交

### 学习笔记
（记录每个阶段的关键收获和踩坑经验）

---

**准备好开始这段旅程了吗？** 🚀

建议先完成第一步（实现 Page 类），有了基础后可以逐步深入每个模块的具体实现细节！
